<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <title>Strobo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://docs.opencv.org/4.x/opencv.js"></script>
    <style>
        @import url('styles.css');
    </style>
</head>

<body>

    <div id="reset"></div>
    <div id="fullscreen"></div>

    <!-- Live-Video -->
    <div id="camera-container">
        <video id="video" autoplay playsinline></video>
        <div id="shutter" class="disabled"></div>
        <div id="toggle-camera"></div>
        <div id="debugInfo"></div>
    </div>

    <!-- Stroboskopbild -->
    <div id="strobe-container" style="display:none;">
        <canvas id="canvasStrobe"></canvas>
        <div id="stroboControls">
            <input type="range" id="interval-slider" min="1" max="10" value="3" />
            <div id="play-button"></div>
        </div>
    </div>

    <script type="module">

        import { createStroboEvaluation } from './strobo.js';

        const video = document.getElementById('video');
        const shutter = document.getElementById('shutter');
        const toggleBtn = document.getElementById('toggle-camera');
        const resetBtn = document.getElementById('reset');
        const fullscreenBtn = document.getElementById('fullscreen');
        const strobeContainer = document.getElementById('strobe-container');
        const intervalSlider = document.getElementById('interval-slider');
        const playButton = document.getElementById('play-button');
        const cameraContainer = document.getElementById('camera-container');

        let usingFront = true; // Frontkamera aktiv
        let currentStream;
        let opencvReady = false;
        let cameraReady = false;
        let recording = false;
        let fps = 0;
        let frames = [];
        let stroboEvaluation;
        let playing = false

        opencvReady = (typeof cv !== 'undefined' && typeof cv.Mat === 'function');
        cv['onRuntimeInitialized'] = () => {
            opencvReady = true;
            updateReady();
        }
    
        function updateReady(){
            const ready = cameraReady && opencvReady;
            if(ready){
                shutter.classList.remove('disabled');
            }
            updateDebugInfo();
        }
        
        function updateDebugInfo(){
            const debugInfo = document.getElementById('debugInfo');

            const params = new URLSearchParams(window.location.search);
            debugInfo.style.display = (params.get('debug') === '1') ? 'flex' : 'none';

            debugInfo.innerHTML = `
                <p>Using Front Camera: ${usingFront}</p>
                <p>Recording: ${recording}</p>
                <p>Frames Captured: ${frames.length}</p>
                <p>Window w/h: ${window.innerWidth}/${window.innerHeight}px</p>
                <p>Video w/h: ${video.videoWidth}/${video.videoHeight}px</p>
                <p>FPS: ${fps}</p>
                <p>OpenCV Ready: ${opencvReady}</p>
                <p>Camera Ready: ${cameraReady}</p>
            `;
        }

        function toggleFullscreen(elem = document.documentElement) {
            const fsElem = document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
            if (!fsElem) {
                (elem.requestFullscreen || elem.webkitRequestFullscreen || elem.msRequestFullscreen).call(elem)?.catch(e => {
                    console.error(e);
                    return false;
                });
                return true;
            } else {
                (document.exitFullscreen || document.webkitExitFullscreen || document.msExitFullscreen).call(document);
                return false;
            }
        }

        async function startCamera() {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
            }

            const facingMode = usingFront ? 'user' : 'environment';

            try {
                currentStream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480, frameRate: { ideal: 30 }, facingMode }
                });
                video.srcObject = currentStream;
                fps = currentStream.getVideoTracks()[0].getSettings().frameRate;
                cameraReady = true;
            } catch (err) {
                alert("Kamera konnte nicht geÃ¶ffnet werden: " + err);
                cameraReady = false;
            }

            updateReady();
            updateDebugInfo();
        }

        toggleBtn.addEventListener('click', () => {
            usingFront = !usingFront;
            startCamera();
        });

        fullscreenBtn.addEventListener('click', () => {
            if (toggleFullscreen()) {
                fullscreenBtn.classList.add('active');
            } else {
                fullscreenBtn.classList.remove('active');
            }
        });

        resetBtn.addEventListener('click', () => {
            window.location.reload();
        });

        intervalSlider.addEventListener('input', () => {
            updateStrobeImage();
        });

        shutter.addEventListener('click', () => {
            if (!shutter.classList.contains('disabled')) {
                onShutter();
            }
        });

        playButton.addEventListener('click', () => {
            if (!playButton.classList.contains('disabled')) {
                if(!playing){
                    playButton.classList.add('active');
                    playing = true;
                } else {
                    playButton.classList.remove('active');
                    playing = false;
                }
            }
        });

        function startRecording() {
            recording = true;
            shutter.classList.add('active');
            frames = [];

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;

            const captureFrame = (now, metadata) => {
                if (!recording) return;
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                frames.push(imageData);
                updateDebugInfo();
                if (frames.length < 500) {
                    video.requestVideoFrameCallback(captureFrame);
                } else {
                    stopRecording();
                }
            };

            video.requestVideoFrameCallback(captureFrame);
        }

        function stopRecording() {
            recording = false;
            shutter.classList.remove('active');
            cameraContainer.style.display = 'none';
            strobeContainer.style.display = 'flex';
            shutter.style.display = 'none';
            intervalSlider.max = Math.floor(frames.length / 5);
            stroboEvaluation = createStroboEvaluation(frames);
            updateStrobeImage();
        }

        function updateStrobeImage(){
            const canvas = document.getElementById('canvasStrobe');
            const context = canvas.getContext('2d');
            if (stroboEvaluation) {
                const imageData = stroboEvaluation.makeStrobeImage(parseInt(intervalSlider.value));
                canvas.width = imageData.width;
                canvas.height = imageData.height;   
                context.putImageData(imageData, 0, 0);
            } else {
                context.clearRect(0, 0, canvas.width, canvas.height);
            }
        }
        
        function onShutter() {
            if (!recording) {
                startRecording();
            } else {
                stopRecording();
            }
        }
            
        startCamera();

    </script>
            
</body>

</html>
