<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <title>Stroboskop-Video</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://docs.opencv.org/4.x/opencv.js"></script>
    <script type="module" src="strobo.js"></script>
    <style>
        @import url('styles.css');
    </style>
</head>

<body>

    <!-- Live-Video -->
    <div id="camera-container">
        <video id="video" autoplay playsinline></video>
        <div id="shutter" class="disabled"></div>
        <img id="toggle-camera" src="switch.svg" />
        <div id="debugInfo"></div>
    </div>

    <!-- Stroboskopbild -->
    <div id="strobe-container" style="display:none;">
        <canvas id="canvasStrobe"></canvas>
        <div id="stroboControls">
            <input type="range" id="interval-slider" min="1" max="10" value="3" />
            <span id="interval-value">3</span>
        </div>
    </div>

    <script type="module">

        import { createStroboEvaluation } from './strobo.js';

        const video = document.getElementById('video');
        const shutter = document.getElementById('shutter');
        const toggleBtn = document.getElementById('toggle-camera');
        const strobeContainer = document.getElementById('strobe-container');
        const intervalSlider = document.getElementById('interval-slider');
        const intervalValue = document.getElementById('interval-value');
        const cameraContainer = document.getElementById('camera-container');

        let usingFront = true; // Frontkamera aktiv
        let currentStream;
        let opencvReady = false;
        let cameraReady = false;
        let recording = false;
        let frames = [];
        let stroboEvaluation;

        opencvReady = (typeof cv !== 'undefined' && typeof cv.Mat === 'function');
        cv['onRuntimeInitialized'] = () => {
            opencvReady = true;
            updateReady();
        }
    
        function updateReady(){
            const ready = cameraReady && opencvReady;
            if(ready){
                shutter.classList.remove('disabled');
            }
            updateDebugInfo();
        }
        
        function updateDebugInfo(){
            const debugInfo = document.getElementById('debugInfo');
            debugInfo.innerHTML = `
                <p>Using Front Camera: ${usingFront}</p>
                <p>Recording: ${recording}</p>
                <p>Frames Captured: ${frames.length}</p>
                <p>Window w/h: ${window.innerWidth}/${window.innerHeight}px</p>
                <p>Video w/h: ${video.videoWidth}/${video.videoHeight}px</p>
                <p>OpenCV Ready: ${opencvReady}</p>
                <p>Camera Ready: ${cameraReady}</p>
            `;
        }

        async function startCamera() {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
            }

            const facingMode = usingFront ? 'user' : 'environment';

            try {
                currentStream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480, frameRate: 30, facingMode }
                });
                video.srcObject = currentStream;
                cameraReady = true;
            } catch (err) {
                alert("Kamera konnte nicht geöffnet werden: " + err);
                cameraReady = false;
            }

            updateReady();
            updateDebugInfo();
        }

        toggleBtn.addEventListener('click', () => {
            usingFront = !usingFront;
            toggleBtn.textContent = usingFront ? 'Frontkamera' : 'Rückkamera';
            startCamera();
        });

        intervalSlider.addEventListener('input', () => {
            intervalValue.textContent = intervalSlider.value;
            if (stroboEvaluation) {
                stroboEvaluation.updateStrobe('canvasStrobe', parseInt(intervalSlider.value));
            }
        });
        
        document.addEventListener('keydown', (e) => {
            if (e.code === 'VolumeUp' || e.code === 'VolumeDown') {
                onShutter();
            }
        });

        shutter.addEventListener('click', () => {
            if (!shutter.classList.contains('disabled')) {
                onShutter();
            }
        });

        function onShutter() {
            if (!recording) {
                recording = true;
                shutter.classList.add('active');
                frames = [];

                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d', { willReadFrequently: true });
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;

                const captureFrame = (now, metadata) => {
                    if (!recording) return;
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    frames.push(imageData);
                    updateDebugInfo();
                    video.requestVideoFrameCallback(captureFrame);
                };

                video.requestVideoFrameCallback(captureFrame);

            } else {
                recording = false;
                shutter.classList.remove('active');
                cameraContainer.style.display = 'none';
                strobeContainer.style.display = 'flex';
                shutter.style.display = 'none';
                intervalValue.textContent = intervalSlider.value;
                intervalSlider.max = Math.floor(frames.length / 5);
                stroboEvaluation = createStroboEvaluation(frames);
                stroboEvaluation.updateStrobe('canvasStrobe', parseInt(intervalSlider.value));
            }
        }
            
        startCamera();

    </script>
            
</body>

</html>